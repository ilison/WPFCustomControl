#region Copyright Syncfusion Inc. 2001-2017.
// Copyright Syncfusion Inc. 2001-2017. All rights reserved.
// Use of this code is subject to the terms of our license.
// A copy of the current license can be obtained at any time by e-mailing
// licensing@syncfusion.com. Any infringement will be prosecuted under
// applicable laws. 
#endregion
using System;
using System.Data;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Windows;
using Syncfusion.Data;
using Syncfusion.Data.Extensions;
#if WinRT || UNIVERSAL
using Windows.UI.Xaml;
using Windows.Foundation;
#endif

namespace Syncfusion.UI.Xaml.Grid
{

    [AttributeUsage(AttributeTargets.Property, Inherited = true)]
    public class CloneableAttribute : Attribute
    {
        public CloneableAttribute(bool isCloneable)
        {
            this.IsCloneable = isCloneable;
        }

        public bool IsCloneable { get; private set; }
    }

    public static class CloneHelper
    {
#if WPF
        private static readonly Dictionary<Type, PropertyDescriptorCollection> PropertiesDescriptorCache = new Dictionary<Type, PropertyDescriptorCollection>();
#else
        private static readonly Dictionary<Type, PropertyInfoCollection> PropertiesDescriptorCache = new Dictionary<Type, PropertyInfoCollection>();
#endif
        
        public static void CloneCollection(IList sourceList, IList destinationList, Type baseType)
        {
            foreach (var sourceItem in sourceList)
            {
                var destinationItem = CreateClonedInstance(sourceItem, baseType);
                var gridcol = destinationItem as GridColumn;
                if (gridcol != null)
                {
                    if (gridcol.IsTemplate)
                    {
                        (destinationItem as GridTemplateColumn).SetValue(FocusManagerHelper.WantsKeyInputProperty,
                            (bool)(sourceItem as GridTemplateColumn).GetValue(FocusManagerHelper.WantsKeyInputProperty));
                    }
                    gridcol.IsAutoGenerated = (sourceItem as GridColumn).IsAutoGenerated;
                    gridcol.isvaluebindingcreated = (sourceItem as GridColumn).isvaluebindingcreated;
                }
                destinationList.Add(destinationItem);
            }
        }

        public static object CreateClonedInstance(object sourceItem, Type baseType)
        {
            var destinationItem = Activator.CreateInstance(sourceItem.GetType());
            CloneProperties(sourceItem, destinationItem, baseType);
            return destinationItem;
        }
        

        public static void CloneProperties(object source, object destination, Type baseType)
        {
            var propertiesDescriptor = GetCloneableProperties(destination.GetType(), baseType);
#if WPF
            foreach (PropertyDescriptor propertyDescriptor in propertiesDescriptor)
            {
#else
            foreach (var keyValuePair in propertiesDescriptor)
            {
                var propertyDescriptor = keyValuePair.Value;
#endif
                var destinationValue = propertyDescriptor.GetValue(destination);
                
                var sourceValue = propertyDescriptor.GetValue(source);
                bool isCopied = false;
                // WPF-17660 - no need to copy unset value for GridColumn properties
                if (source is GridColumn)
                {
#if WPF
                    var dp = CloneHelper.GetDependencyPropertyByName(typeof(GridColumn), propertyDescriptor.Name+ "Property");         
#else
                     var dp = CloneHelper.GetDependencyPropertyByName(typeof(GridColumn), keyValuePair.Key + "Property");
#endif
                    if (dp != null)
                    {
                        var value = (source as GridColumn).ReadLocalValue(dp);
                        if (value != DependencyProperty.UnsetValue)
                        {
                            propertyDescriptor.SetValue(destination, sourceValue);
                        }
                        isCopied = true;
                    }
                }
                if (!isCopied)
                {
                    if (!object.Equals(destinationValue, sourceValue))
                    {
                        propertyDescriptor.SetValue(destination, sourceValue);
                    }
                }
            }
        }

        public static DependencyProperty GetDependencyPropertyByName(Type dependencyObjectType, string dpName)
        {
            DependencyProperty dp = null;
            var fieldInfo = dependencyObjectType.GetField(dpName, BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy);
            if (fieldInfo != null)
            {
                dp = fieldInfo.GetValue(null) as DependencyProperty;
            }
            return dp;
        }

#if WPF
        public static PropertyDescriptor GetCloneableProperty(Type type, Type baseType, string property)
#else
        public static PropertyInfo GetCloneableProperty(Type type, Type baseType, string property)
#endif
        {
            var descriptor = GetCloneableProperties(type, baseType);
#if !WPF
            return descriptor.ContainsKey(property) ? descriptor[property] : null;
#else
            return descriptor[property];
#endif
        }

#if WPF
        private static PropertyDescriptorCollection GetCloneableProperties(Type destinationType, Type baseType)
        {
            PropertyDescriptorCollection descriptor;
            if (!PropertiesDescriptorCache.TryGetValue(destinationType, out descriptor))
            {
                var list = new List<PropertyDescriptor>();
                foreach (PropertyDescriptor propertyDescriptor in TypeDescriptor.GetProperties(destinationType))
                {
                    var item = GetCloneableProperty(propertyDescriptor, baseType);
                    if (item != null)
                        list.Add(item);
                }
                descriptor = new PropertyDescriptorCollection(list.ToArray());
                PropertiesDescriptorCache.Add(destinationType, descriptor);
            }
            return descriptor;
        }
#else
        private static PropertyInfoCollection GetCloneableProperties(Type destinationType, Type baseType)
        {
            PropertyInfoCollection descriptor;
            if (!PropertiesDescriptorCache.TryGetValue(destinationType, out descriptor))
            {
                descriptor = new PropertyInfoCollection();
                foreach (var propertyInfo in destinationType.GetProperties())
                {
                    var item = GetCloneableProperty(propertyInfo, baseType);
                    if (item != null) 
                        descriptor.Add(item.Name, item);
                }
                PropertiesDescriptorCache.Add(destinationType, descriptor);
            }
            return descriptor;
        }
#endif

#if WPF
        private static PropertyDescriptor GetCloneableProperty(PropertyDescriptor property, Type baseType)
#else
        private static PropertyInfo GetCloneableProperty(PropertyInfo property, Type baseType)
#endif
        {
#if WPF
            var attribute = property.Attributes[typeof(CloneableAttribute)] as CloneableAttribute;
#else
            var attribute = property.GetCustomAttributes(typeof(CloneableAttribute), true).FirstOrDefault() as CloneableAttribute;
#endif
            if (attribute != null && !attribute.IsCloneable)
                return null;
#if WPF
            if (property.IsReadOnly)
#else
            if (!property.CanWrite)
#endif
                return null;
            if (property.Name == "Resources")
                return null;
#if WPF
            if (!baseType.IsAssignableFrom(property.ComponentType))
#else
            if (!baseType.IsAssignableFrom(property.DeclaringType))
#endif
                return null;

            return property;
        }


        public static void EnsureCollection<T, S>(T source, T target, Func<S, S, bool> predicate) where T : IList<S>
        {
            // Need to check whether all the elements in the collection is equal. If it is equal, no need to clone collection
            if (source.Count != target.Count || !source.All(sourceitem => target.Any(targetitem => predicate(targetitem, sourceitem))))
            {
                target.Clear();
                CloneCollection((IList)source, (IList)target, typeof(S));                
            }            
        }
    }

    internal static class DetailsViewHelper
    {
        internal static bool[] GetHiddenPattern(this DetailsViewManager Manager)
        {
            var hiddenPattern = new List<bool> { false };
            Manager.DataGrid.DetailsViewDefinition.ForEach(r => hiddenPattern.Add(true));
            return hiddenPattern.ToArray();
        }

        /// <summary>
        /// Check BeginInit is already called. If not need to call BeginInit
        /// </summary>
        /// <param name="view">View</param>
        internal static void BeginInit(ICollectionViewAdv view)
        {
            // If view is not in DeferRefresh, need to call BeginInit
            if (!view.IsInDeferRefresh)
            {
                view.BeginInit();
            }
        }

        /// <summary>
        /// Get child source count to decide whether details view data row should be visible or not in case of HideEmptyGridViewDefinition is True
        /// </summary>
        /// <param name="source">Child itemssource</param>
        /// <returns>Child itemssource count</returns>
        internal static int GetChildSourceCount(object source)
        {
            if (source == null)
                return 0;
#if WPF
            if (source is DataView)
                return (source as DataView).Count;
#endif
            if (source is IEnumerable)
                return (source as IEnumerable).AsQueryable().Count();
            throw new NotImplementedException(source.GetType() + "Not supported");
        }
        /// <summary>
        /// Get the level of particular DetailsViewDefinition
        /// </summary>
        /// <returns>Level</returns>
        internal static int GetDefinitionLevel(this DetailsViewManager manager, GridViewDefinition gridViewDefinition)
        {
            if (manager.DataGrid.DetailsViewDefinition == null || !manager.DataGrid.DetailsViewDefinition.Any())
                return 0;
            var hasDefintion = manager.DataGrid.DetailsViewDefinition.Contains(gridViewDefinition);
            if (hasDefintion)
                return 1;
            else
                foreach (var defintion in manager.DataGrid.DetailsViewDefinition)
                {
                    return 1 + (defintion as GridViewDefinition).DataGrid.DetailsViewManager.GetDefinitionLevel(gridViewDefinition);
                }
            return 0;
        }

        /// <summary>
        /// Get the record in the specified row Index
        /// </summary>
        /// <param name="rowIndex">rowIndex</param>
        /// <returns>RecordEntry</returns>
        internal static RecordEntry GetDetailsViewRecord(this DetailsViewManager manager, int rowIndex)
        {
            RecordEntry record = null;
            if (manager.DataGrid.GridModel.HasGroup)
            {
                var recordIndex = manager.DataGrid.ResolveToGroupRecordIndexForDetailsView(rowIndex);
                if (recordIndex >= 0)
                   record = manager.DataGrid.View.TopLevelGroup.DisplayElements[recordIndex] as RecordEntry;
            }
            else
            {
                var recordIndex = manager.DataGrid.ResolveToRecordIndex(rowIndex);
                if (recordIndex >= 0)
                  record = manager.DataGrid.View.Records[recordIndex];
            }
            return record;
        }

        /// <summary>
        /// Check whther any othe childview contains records
        /// </summary>
        /// <param name="record">RecordEntry</param>
        /// <returns>true if any child contains record</returns>
        internal static bool HasChildSource(this DetailsViewManager manager, RecordEntry record)
        {
            var provider = manager.DataGrid.View.GetPropertyAccessProvider();
            foreach (var definition in manager.DataGrid.DetailsViewDefinition)
            {
                var childSource = provider.GetValue(record.Data, definition.RelationalColumn) as IEnumerable;
                if (childSource != null && DetailsViewHelper.GetChildSourceCount(childSource) > 0)
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Get GridViewDefinition with the specified index
        /// </summary>
        /// <param name="index">index</param>
        /// <returns>ViewDefinition</returns>
        internal static ViewDefinition GetGridViewDefinition(this DetailsViewManager manager, int index)
        {
            if (!(manager.DataGrid.DetailsViewDefinition.Count > index))
                return null;
            // If the grid is DetailsViewDataGrid, need to get DetailsViewDefinition from Root DataGrid. Else get from main grid itself
            if (manager.DataGrid is DetailsViewDataGrid && manager.DataGrid.NotifyListener != null)
                return manager.DataGrid.NotifyListener.SourceDataGrid.DetailsViewDefinition[index];
            else
                return manager.DataGrid.DetailsViewDefinition[index];
        }

        /// <summary>
        /// // To refresh parent grid height in case of multi level nested grid and grouping
        /// </summary>
        /// <param name="datagrid">datagrid</param>
        internal static void RefreshParentDataGridRows(SfDataGrid datagrid)
        {
            if (!(datagrid is DetailsViewDataGrid) || datagrid.NotifyListener == null) return;
            var parentGrid = datagrid.NotifyListener.GetParentDataGrid();
            RefreshParentDataGridRows(parentGrid);
            parentGrid.VisualContainer.ScrollRows.MarkDirty();
        }

        /// <summary>
        /// While reusing DetailsViewDataRow, need to clear DetailsViewDataGrid properties 
        /// </summary>
        /// <param name="view">DetailsViewDataGrid's view</param>
        internal static void ClearViewProperties(ICollectionViewAdv view)
        {
            // Check view is in Defer refresh
            var isIndeferRefresh = view.IsInDeferRefresh;
            if (view.SortDescriptions != null && view.SortDescriptions.Any())
            {
                DetailsViewHelper.BeginInit(view);
                view.SortDescriptions.Clear();
            }
            if (view.FilterPredicates != null && view.FilterPredicates.Any())
            {
                DetailsViewHelper.BeginInit(view);
                view.FilterPredicates.Clear();
            }
            if (view.GroupDescriptions != null && view.GroupDescriptions.Any())
            {
                DetailsViewHelper.BeginInit(view);
                view.GroupDescriptions.Clear();
            }

            if (view.SortComparers != null && view.SortComparers.Any())
            {
                DetailsViewHelper.BeginInit(view);
                view.SortComparers.Clear();
            }
            if (view.Filter != null)
            {
                DetailsViewHelper.BeginInit(view);
                view.Filter = null;
            }
            if (view.GroupComparer != null)
            {
                DetailsViewHelper.BeginInit(view);
                view.GroupComparer = null;
            }
            if (view.CaptionSummaryRow != null)
            {
                DetailsViewHelper.BeginInit(view);
                view.CaptionSummaryRow = null;
            }
            if (view.SummaryRows != null && view.SummaryRows.Any())
            {
                DetailsViewHelper.BeginInit(view);
                view.SummaryRows.Clear();
            }
            if (view.TableSummaryRows != null && view.TableSummaryRows.Any())
            {
                DetailsViewHelper.BeginInit(view);
                view.TableSummaryRows.Clear();
            }
            // If view is in DeferRefresh and already BeginInit is not called, need to call EndInit
            if (view.IsInDeferRefresh && !isIndeferRefresh)
                view.EndInit();
        }

        internal static Rect SubtractDetailsViewPadding(this DetailsViewManager manager, Rect cellRect)
        {
            var thickness = manager.DataGrid.DetailsViewPadding;
            if (cellRect.IsEmpty || cellRect.Width <= thickness.Left + thickness.Right || cellRect.Height <= thickness.Top + (2 * thickness.Bottom))
                return cellRect;

            cellRect.Height -= (thickness.Bottom + thickness.Top);
            cellRect.Y += thickness.Top;
            cellRect.Width -= (thickness.Right + thickness.Left);
            cellRect.X += thickness.Left;

            return cellRect;
        }

        internal static void ScrollInViewAllDetailsViewParent(SfDataGrid dataGrid)
        {
            if (!(dataGrid is DetailsViewDataGrid) || dataGrid.NotifyListener == null) return;
            var detailsViewOffset = dataGrid.VisualContainer.HorizontalOffset;
            var parentGrid = dataGrid.NotifyListener.GetParentDataGrid();
            //When navigating using Tab key in DetailsViewDataGrid, the current column is clipped when navigating to out of view column. 
            //Because while updating the ParentGrid scrollbar value, the ExpanderCell width is need to be subtracted from parent grid HorizontalOffSet because the parent grid HorizontalOffSet is different from NestedGrid HorizontalOffset
            var indentCellWidth = parentGrid.VisualContainer.HorizontalOffset != 0 && parentGrid.ShowRowHeader != true ? parentGrid.ExpanderColumnWidth : 0;
            var parentGridOffset = parentGrid.VisualContainer.HorizontalOffset - indentCellWidth;
            //When Child grid width is greater than the ParenGrid the ChildGrid column is not comes to view when pressing Tab key,
            //because the ParentGrid ScrollBar value has been changed, hence the below code has been added.
            if (parentGrid.VisualContainer.ScrollColumns.ScrollBar.Maximum > dataGrid.VisualContainer.ScrollColumns.ScrollBar.Maximum)
            {
                if (parentGridOffset < detailsViewOffset)
                {
                    var delta = detailsViewOffset - parentGridOffset;
                    parentGrid.VisualContainer.ScrollColumns.ScrollBar.Value += delta;
                }
                else
                {
                    var delta = parentGridOffset - detailsViewOffset;
                    parentGrid.VisualContainer.ScrollColumns.ScrollBar.Value -= delta;
                }
            }

            if (parentGrid is DetailsViewDataGrid && parentGrid.NotifyListener != null)
                ScrollInViewAllDetailsViewParent(parentGrid);
        }

    }
}
